/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *  
 * http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.   
 */

/**
 *  An JP QL grammar parser.
 *  It is based on the parser of OpenJPA by Patrick Linskey and Marc Prud"hommeaux
 *  @author Arne Limburg
 */
options {
    JDK_VERSION = "1.7";
    NODE_PREFIX = "Jpql";
    NODE_PACKAGE = "org.jpasecurity.jpql.parser";
    VISITOR = true;
    MULTI = true;
    NODE_DEFAULT_VOID = true;
    JAVA_UNICODE_ESCAPE = true;
    JAVA_TEMPLATE_TYPE = "modern";
    UNICODE_INPUT = true;
    STATIC = false;
    NODE_USES_PARSER = true;
    LOOKAHEAD = 1;

    // debugging variables
    //DEBUG_PARSER = true;             // simple parser debug
    //DEBUG_TOKEN_MANAGER = true;      // more verbose token manager debug
    //DEBUG_LOOKAHEAD = true;          // more verbose lookahead debug
    SANITY_CHECK = true;                // check for left-recursion, etc (must always be true)

    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(JpqlParser)
package org.jpasecurity.jpql.parser;

public class JpqlParser {

    public JpqlParser() throws ParseException {
        this("");
    }

    public JpqlStatement parseQuery(String query) throws ParseException {
        ReInit(query);
        return jpqlStatement();
    }

    public JpqlAccessRule parseRule(String accessRule) throws ParseException {
        ReInit(accessRule);
        return jpqlAccessRule();
    }

    public JpqlWhere parseWhereClause(String whereClause) throws ParseException {
        ReInit(whereClause);
        return whereClause();
    }
}
PARSER_END(JpqlParser)

SKIP: {
    " "
    | "\n"
    | "\r"
    | "\t"
}

TOKEN[IGNORE_CASE]: {
    <COMMA: ",">
    | <COLON: ":">
    | <QUESTION_MARK: "?">

    | <DOT: ".">

    | <EQ: "=">
    | <NE: "<>">
    | <NEQ: "!=">
    | <GT: ">">
    | <GE: ">=">
    | <LT: "<">
    | <LE: "<=">

    | <PLUS: "+">
    | <MINUS: "-">

    | <TIMES: "*">
    | <DIV: "/">

    | <NEW: "NEW">

    | <ALL: "ALL">
    | <ANY: "ANY">
    | <EXISTS: "EXISTS">
    | <SOME: "SOME">
    | <EMPTY: "EMPTY">

    | <ASC: "ASC">
    | <DESC: "DESC">
    | <ORDER: "ORDER">
    | <BY: "BY">

    | <IS: "IS">
    | <MEMBER: "MEMBER">
    | <OF: "OF">
    | <LIKE: "LIKE">
    | <ESCAPE: "ESCAPE">
    | <BETWEEN: "BETWEEN">

    | <NULL: "NULL">
    | <KEY: "KEY">
    | <VALUE: "VALUE">
    | <TYPE: "TYPE">
    | <ENTRY: "ENTRY">
}

TOKEN[IGNORE_CASE]: { /* aggregates */
    <AVG: "AVG">
    | <MIN: "MIN">
    | <MAX: "MAX">
    | <SUM: "SUM">
    | <COUNT: "COUNT">
}

TOKEN[IGNORE_CASE]: { /* boolean arithmetic */
    <OR: "OR">
    | <AND: "AND">
    | <NOT: "NOT">
}

TOKEN: { /* query hints */
    <QUERY_OPTIMIZE_NOCACHE: "QUERY_OPTIMIZE_NOCACHE">
    | <IS_ACCESSIBLE_NOCACHE: "IS_ACCESSIBLE_NOCACHE">
    | <IS_ACCESSIBLE_NODB: "IS_ACCESSIBLE_NODB">
}

TOKEN[IGNORE_CASE]: { /* functions returning strings */
    <CONCAT: "CONCAT">
    | <SUBSTRING: "SUBSTRING">
    | <TRIM: "TRIM">
    | <LOWER: "LOWER">
    | <UPPER: "UPPER">
}

TOKEN[IGNORE_CASE]: { /* trim specification */
    <LEADING: "LEADING">
    | <TRAILING: "TRAILING">
    | <BOTH: "BOTH">
}

TOKEN[IGNORE_CASE]: { /* functions returning numerics */
    <LENGTH: "LENGTH">
    | <LOCATE: "LOCATE">
    | <ABS: "ABS">
    | <SQRT: "SQRT">
    | <MOD: "MOD">
    | <SIZE: "SIZE">
    | <INDEX: "INDEX">
}

TOKEN[IGNORE_CASE]: { /* functions returning datetime */
    <CURRENT_DATE: "CURRENT_DATE">
    | <CURRENT_TIME: "CURRENT_TIME">
    | <CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
}

TOKEN[IGNORE_CASE]: { /* type of query */
    <SELECT: "SELECT">
    | <DISTINCT: "DISTINCT">
    | <FROM: "FROM">

    | <UPDATE: "UPDATE">
    | <DELETE: "DELETE">

    | <WHERE: "WHERE">
    | <GROUP: "GROUP">
    | <HAVING: "HAVING">
    | <TREAT: "TREAT">

    | <AS: "AS">
    | <LEFT: "LEFT">
    | <OUTER: "OUTER">
    | <INNER: "INNER">
    | <JOIN: "JOIN">
    | <FETCH: "FETCH">
    | <IN: "IN">
    | <SET: "SET">

    | <OBJECT: "OBJECT">

    | <CASE: "CASE">
    | <WHEN: "WHEN">
    | <ELSE: "ELSE">
    | <THEN: "THEN">
    | <END: "END">
    | <NULLIF: "NULLIF">
    | <COALESCE: "COALESCE">
    | <CLASS: "CLASS">

    | <GRANT: "GRANT">
    | <CREATE: "CREATE">
    | <READ: "READ">
    | <ACCESS: "ACCESS">
    | <TO: "TO">

    | <ON: "ON">
    | <FUNCTION: "FUNCTION">

    | <CURRENT_PRINCIPAL: "CURRENT_PRINCIPAL">
    | <CURRENT_ROLES: "CURRENT_ROLES">
    | <CURRENT_TENANT: "CURRENT_TENANT">
}

/* inspired by the Java 1.0.2 specification */
/* ### should we limit this to the length that is valid in java? */
TOKEN: /* literals */
{
    <LEFT_PAREN: "(">
    | <RIGHT_PAREN: ")">
    | <LEFT_BRACKET: "[">
    | <RIGHT_BRACKET: "]">
    | <LEFT_BRACE: "{">
    | <RIGHT_BRACE: "}">

    | < #LONG_SUFFIX: ("l"|"L") >
    | < #FLOAT_SUFFIX: ("f"|"F") >
    | < #DOUBLE_SUFFIX: ("d"|"d") >
    | < #BIG_DECIMAL_SUFFIX: ("bd"|"BD") >
    | < #SINGLE_DIGIT: ["0"-"9"] >
    | < #SINGLE_NON_ZERO_DIGIT: ["1"-"9"] >
    | < #OCTAL_DIGIT: ["0"-"7"] >
    | < #SPECIAL_CHARS: ("\\" ("b" | "t" | "n" | "f" | "r" | "\\" | "\"" |"\\" )) >
    | < #UNICODE_ESCAPE: ("\\" "u" <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT>) >
    | < #OCTAL_ESCAPE:
        "\\" (
            ["0"-"3"] <OCTAL_DIGIT> <OCTAL_DIGIT>
            | <OCTAL_DIGIT> <OCTAL_DIGIT>
            | <OCTAL_DIGIT>
        )
      >
    | < #ESCAPE_SEQUENCE: (<SPECIAL_CHARS> | <UNICODE_ESCAPE> | <OCTAL_ESCAPE>) >
    | < #INTEGER_NUMBER: ("0" | ["1"-"9"] (<SINGLE_DIGIT>)*) >
    | < #HEX_DIGIT: "0" ("x"|"X") (["a"-"f"] | ["A"-"F"]) >
    | < #EXPONENT: ["e","E"] (["+","-"])? (<SINGLE_DIGIT>)+ >
    | < INTEGER_LITERAL: <INTEGER_NUMBER> >
    | < LONG_LITERAL: <INTEGER_NUMBER> <LONG_SUFFIX> >
    | < BIG_INTEGER_LITERAL: <INTEGER_NUMBER> ("bi"|"BI") >
    | < HEX_LITERAL: "0" ("x"|"X") (<HEX_DIGIT>)+ (<LONG_SUFFIX>)? >
    | < OCTAL_LITERAL: "0" (<OCTAL_DIGIT>)+  >
    | < FLOATING_POINT_NUMBER:
        (<SINGLE_DIGIT>)+ <DOT> (<SINGLE_DIGIT>)* (<EXPONENT>)?
        | <DOT> (<SINGLE_DIGIT>)+ (<EXPONENT>)?
        | (<SINGLE_DIGIT>)+ (<EXPONENT>)?
        | (<SINGLE_DIGIT>)+ (<EXPONENT>)
        | (<SINGLE_DIGIT>)+
      >
    | < FLOAT_LITERAL: <FLOATING_POINT_NUMBER> (<FLOAT_SUFFIX>)? >
    | < DOUBLE_LITERAL: <FLOATING_POINT_NUMBER> <DOUBLE_SUFFIX> >
    | < BIG_DECIMAL_LITERAL: <FLOATING_POINT_NUMBER> <BIG_DECIMAL_SUFFIX> >
    | < CHARACTER_LITERAL: "'" ( <ESCAPE_SEQUENCE> | (~["'","\\","\n","\r"]) ) "'" >
    | < STRING_LITERAL: (
        "\"" (<ESCAPE_SEQUENCE> | ("\"\"" | ~["\""]))* "\""
        | "'" (<ESCAPE_SEQUENCE> | (~["'"]) )* "'"
        )
      >
    | < DATE_LITERAL: "{d \"" (["0"-"9", "-"])* "\"}" >
    | < TIME_LITERAL: "{t \"" (["0"-"9", ":"])* "\"}" >
    | < TIMESTAMP_LITERAL: "{ts \"" (["0"-"9", "-", ":", " ", "."])* "\"}" >
}

TOKEN[IGNORE_CASE]: { /* boolean literals can be case-insensitive */
    < BOOLEAN_LITERAL: "TRUE" | "FALSE" >
}

/* From the Java 1.0.2 specification */
TOKEN : /* IDENTIFIERS */
{
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
    | < #LETTER: [
        "\u0024",             // $
        "\u0041"-"\u005a",     // A-Z
        "\u005f",             // _
        "\u0061"-"\u007a",     // a-z
        "\u00c0"-"\u00d6",
        "\u00d8"-"\u00f6",
        "\u00f8"-"\u00ff",
        "\u0100"-"\u1fff",
        "\u3040"-"\u318f",
        "\u3300"-"\u337f",
        "\u3400"-"\u3d2d",
        "\u4e00"-"\u9fff",
        "\uf900"-"\ufaff"
            ] >
    | < #DIGIT: [
       "\u0030"-"\u0039",     // 0-9
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
            ] >
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// GRANT clause

JpqlAccessRule jpqlAccessRule() #AccessRule: {} {
    <GRANT> [<CREATE> #Create][<READ> #Read][<UPDATE> #Update][<DELETE> #Delete] <ACCESS> toClause() [whereClause()]
    {
        return jjtThis;
    }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// TO clause

void toClause() #From: {} {
    <TO> rangeVariableDeclaration() #IdentificationVariableDeclaration
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// JPQL statement

JpqlStatement jpqlStatement() #Statement: {} {
    (selectStatement() | updateStatement() | deleteStatement()) <EOF> { return jjtThis; }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// SELECT statement

void selectStatement() #Select: {} {
    selectClause() fromClause() [whereClause()] [groupByClause()] [havingClause()] [orderByClause()]
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// UPDATE statement

void updateStatement() #Update: {} {
    updateClause() [whereClause()]
}

void updateClause(): {} {
    <UPDATE> rangeVariableDeclaration() setClause()
}

void setClause() #SetClause: {} {
    <SET> updateItem() ( <COMMA> updateItem() )*
}

void updateItem() #UpdateItem: {} {
    updateItemLhs() <EQ> newValue()
}

void updateItemLhs(): {} {
    [ LOOKAHEAD(2) identificationVariable() <DOT> ] ( LOOKAHEAD(2) singleValuedEmbeddableObjectField() <DOT> )*
        ( LOOKAHEAD(stateField()) stateField() | LOOKAHEAD(singleValuedObjectField()) singleValuedObjectField() )
}

void newValue() #UpdateValue: {} {
    LOOKAHEAD(scalarExpression()) scalarExpression()
    | LOOKAHEAD(simpleEntityExpression()) simpleEntityExpression()
    | LOOKAHEAD(1) <NULL>
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// DELETE clause

void deleteStatement() #Delete: {} {
    deleteClause() [whereClause()]
}

void deleteClause() #From: {} {
    <DELETE> <FROM> entityName() [optionalPathQualifier()]
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// FROM clause

void fromClause() #From: {} {
    <FROM> identificationVariableDeclaration() ( <COMMA> fromItem() )*
}

void fromItem(): {} {
    identificationVariableDeclaration() | collectionMemberDeclaration()
}

void optionalPathQualifier() #OptionalPathQualifier: {} {
    [<AS>] identificationVariable()
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// JOIN clause

void join() #Join: {} {
    joinSpec() joinAssociationPathExpression() optionalPathQualifier() [LOOKAHEAD(1) joinCondition()]
}

void fetchJoin() #FetchJoin: {} {
    joinSpec() <FETCH> joinAssociationPathExpression() [optionalPathQualifier()]
}

void joinAssociationPathExpression() #CollectionValuedPath: {} {
    // a join path is any dot-separated path expression starting with a
    // non-reserved word containing at minimum two path components
    identificationVariable() (<DOT> objectField())+
    | LOOKAHEAD(treatJoin()) treatJoin() [LOOKAHEAD(1) <AS>] identificationVariable() #TreatJoin
}

void treatJoin() #TreatJoin: {} {
    <TREAT> <LEFT_PAREN> joinAssociationPathExpression() [<AS>] identificationVariable() <RIGHT_PAREN>
}

void joinCollectionValuedPathExpression(): {} {
    identificationVariable() [<DOT> singleValuedEmbeddableObjectField()] <DOT> collectionValuedField()
}

void joinSingleValuedPathExpression(): {} {
    identificationVariable() [<DOT> singleValuedEmbeddableObjectField()] <DOT> singleValuedObjectField()
}

void treatedCollectionValuedPathExpression(): {} {
    <TREAT> <LEFT_PAREN> joinCollectionValuedPathExpression() <AS> subType() <RIGHT_PAREN>
}

void treatedSingleValuedPathExpression(): {} {
    <TREAT> <LEFT_PAREN> joinSingleValuedPathExpression() <AS> subType() <RIGHT_PAREN>
}

void joinSpec() #JoinSpec: { Token t = null; } {
    { jjtThis.setValue(""); }
    (t=<LEFT> { jjtThis.setValue(jjtThis.getValue() + t.image); } (t=<OUTER> { jjtThis.setValue(jjtThis.getValue() + t.image); })? | t=<INNER> { jjtThis.setValue(jjtThis.getValue() + t.image); })? t=<JOIN> { jjtThis.setValue(jjtThis.getValue() + t.image); }
}

void joinCondition() #JoinCondition: {} {
    <ON> conditionalExpression()
}

void collectionMemberDeclaration() #InCollection: {} {
    <IN> <LEFT_PAREN> collectionValuedPathExpression() <RIGHT_PAREN> optionalPathQualifier()
}





void identificationVariableDeclaration() #IdentificationVariableDeclaration: {} {
    rangeVariableDeclaration() (LOOKAHEAD(fetchJoin()) fetchJoin() | LOOKAHEAD(join()) join())*
}

void rangeVariableDeclaration() #FromItem: {} {
    entityName() [LOOKAHEAD(1) <AS>] [LOOKAHEAD(identificationVariable()) identificationVariable()]
}

void qualifiedPathExpression() #Path: {} {
    generalIdentificationVariable() (LOOKAHEAD(2) <DOT> objectField())+
}

void subType(): {} {
    entityName()
}

void simpleEntityExpression(): {} {
    identificationVariable() | inputParameter()
}

void distinct() #Distinct: {} {
    <DISTINCT>
}

void aggregatePath() #AggregatePath: {} {
    <LEFT_PAREN> (
        LOOKAHEAD(arithmeticExpression()) arithmeticExpression() |
        LOOKAHEAD(distinctPath()) distinctPath() |
        LOOKAHEAD(singleValuedPathExpression()) singleValuedPathExpression() |
        LOOKAHEAD(identificationVariable()) identificationVariable()
    ) <RIGHT_PAREN>
}

void distinctPath() #DistinctPath: {} {
    <DISTINCT> (LOOKAHEAD(singleValuedPathExpression()) singleValuedPathExpression() | identificationVariable())
}

void count() #Count: {} {
    <COUNT> aggregatePath()
}

void avg() #Average: {} {
    <AVG> aggregatePath()
}

void max() #Maximum: {} {
    <MAX> aggregatePath()
}

void min() #Minimum: {} {
    <MIN> aggregatePath()
}

void sum() #Sum: {} {
    <SUM> aggregatePath()
}

void subQueryInBrackets() #Brackets: {} {
    <LEFT_PAREN> subQuery() <RIGHT_PAREN>
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CONDITIONALS

void conditionalExpression(): {} {
    conditionalExpressionAnd() (LOOKAHEAD(2) <OR> (conditionalExpression() #Or(2)))*
}

void conditionalExpressionAnd(): {} {
    conditionalExpressionNot() (LOOKAHEAD(2) <AND> (conditionalExpression() #And(2)))*
}

void conditionalExpressionNot(): {} {
    LOOKAHEAD(<NOT> conditionalPrimary()) (<NOT> conditionalPrimary() #Not) | conditionalPrimary()
}

void conditionalPrimary(): {} {
    <LEFT_PAREN> (conditionalExpression() #Brackets) <RIGHT_PAREN>
    | LOOKAHEAD(comparisonExpression()) comparisonExpression()
    | LOOKAHEAD(betweenExpression()) betweenExpression()
    | LOOKAHEAD(inExpression()) inExpression()
    | LOOKAHEAD(likeExpression()) likeExpression()
    | LOOKAHEAD(nullComparisonExpression()) nullComparisonExpression()
    | LOOKAHEAD(emptyCollectionComparisonExpression()) emptyCollectionComparisonExpression()
    | LOOKAHEAD(collectionMemberExpression()) collectionMemberExpression()
    | LOOKAHEAD(existsExpression()) existsExpression()
    | LOOKAHEAD(functionInvocation()) functionInvocation()
}

void comparisonExpression(): {} {
    stringExpression() comparisonOperator() ( stringExpression() | allOrAnyExpression() )
                                                                            #StringComparison
    | booleanExpression() comparisonOperator() ( booleanExpression() | allOrAnyExpression() )
                                                                            #BooleanComparison
    | enumExpression() comparisonOperator() ( enumExpression() | allOrAnyExpression() )
                                                                            #EnumComparison
    | dateTimeExpression() comparisonOperator() ( dateTimeExpression() | allOrAnyExpression() )
                                                                            #DateTimeComparison
    | entityExpression() comparisonOperator() ( entityExpression() | allOrAnyExpression() )
                                                                            #EntityComparison
    | arithmeticExpression() comparisonOperator() ( arithmeticExpression() | allOrAnyExpression() )
                                                                            #NumericComparison
    | entityTypeExpression() comparisonOperator() ( entityTypeExpression() | allOrAnyExpression() )
                                                                            #EntityTypeComparison
}

void comparisonOperator() #ComparisonOperator: {} {
    <EQ>                                                                    #Equals
    | LOOKAHEAD(2) <GT>                                                     #GreaterThan
    | LOOKAHEAD(2) <GT>                                                     #GreaterOrEquals
    | LOOKAHEAD(2) <LT>                                                     #LessThan
    | LOOKAHEAD(2) <LE>                                                     #LessOrEquals
    | <NE>                                                                  #NotEquals
}

void betweenExpression() #Between: {} {
    LOOKAHEAD(arithmeticExpression()) arithmeticExpression() [<NOT> #Not] <BETWEEN> arithmeticExpression() <AND> arithmeticExpression()
    | LOOKAHEAD(stringExpression()) stringExpression() [<NOT> #Not] <BETWEEN> stringExpression() <AND> stringExpression()
    | LOOKAHEAD(dateTimeExpression()) dateTimeExpression() [<NOT> #Not] <BETWEEN> dateTimeExpression() <AND> dateTimeExpression()
}

void inExpression() #In: {} {
    (stateValuedPathExpression() | typeDiscriminator() | stringExpression()) [<NOT> #Not] <IN> (
        <LEFT_PAREN> inItem() ( <COMMA> inItem() )* <RIGHT_PAREN>
        | LOOKAHEAD(subQueryInBrackets()) subQueryInBrackets()
        | <LEFT_PAREN> <CURRENT_ROLES> <RIGHT_PAREN>
        | <CURRENT_ROLES>
        | collectionValuedInputParameter()
    )
}

void inItem(): {} {
    literal()
    | singleValuedInputParameter()
}

void likeExpression() #Like: {} {
    stringExpression() [<NOT> #Not] <LIKE> patternValue() [<ESCAPE> escapeCharacter()]
}

void patternValue() #PatternValue: {} {
    inputParameter() | stringLiteral()
}

void escapeCharacter() #EscapeCharacter: { Token token; } {
    characterLiteral()
}

void nullComparisonExpression() #IsNull: {} {
    (inputParameter() | singleValuedPathExpression()) <IS> [<NOT> #Not] <NULL>
}

void emptyCollectionComparisonExpression() #IsEmpty: {} {
    collectionValuedPathExpression() <IS> [<NOT> #Not] <EMPTY>
}

void collectionMemberExpression() #MemberOf: {} {
    entityOrValueExpression() [<NOT> #Not] <MEMBER> [<OF>] collectionValuedPathExpression()
}

void entityOrValueExpression() #EntityOrValueExpression: {} {
    LOOKAHEAD(singleValuedObjectPathExpression()) singleValuedObjectPathExpression()
    | LOOKAHEAD(stateValuedPathExpression()) stateValuedPathExpression()
    | LOOKAHEAD(simpleEntityOrValueExpression()) simpleEntityOrValueExpression()
}

void simpleEntityOrValueExpression() #SimpleEntityOrValueExpression: {} {
    identificationVariable()
    | inputParameter()
    | literal()
}

void existsExpression() #Exists: {} {
    [<NOT> #Not] <EXISTS> <LEFT_PAREN> subQuery() <RIGHT_PAREN>
}

void allOrAnyExpression(): {} {
    allExpression() | anyExpression() | someExpression()
}

void anyExpression() #Any: {} {
    <ANY> <LEFT_PAREN> subQuery() <RIGHT_PAREN>
}

void someExpression() #Any: {} {
    // SOME and ANY are synonymous
    <SOME> <LEFT_PAREN> subQuery() <RIGHT_PAREN>
}

void allExpression() #All: {} {
    <ALL> <LEFT_PAREN> subQuery() <RIGHT_PAREN>
}

void subQuery() #Subselect: {} {
    simpleSelectClause()
        subQueryFromClause()
        [LOOKAHEAD(whereClause()) whereClause()]
        [LOOKAHEAD(groupByClause()) groupByClause()]
        [LOOKAHEAD(havingClause()) havingClause()]
}

void simpleSelectClause() #SelectClause: {} {
    <SELECT> [hint()] [distinct()] simpleSelectExpression()
}

void subQueryFromClause() #From: {} {
    <FROM> subQueryFromItem() ( LOOKAHEAD(1) <COMMA> subQueryFromItem() )*
}

void subQueryFromItem(): {} {
    LOOKAHEAD(subQueryIdentificationVariableDeclaration()) subQueryIdentificationVariableDeclaration()
    | LOOKAHEAD(collectionMemberDeclaration()) collectionMemberDeclaration()
}

void subQueryIdentificationVariableDeclaration(): {} {
    identificationVariableDeclaration()
    | derivedPathExpression() optionalPathQualifier() ( join() )*
    | derivedCollectionMemberDeclaration()
}

void simpleSelectExpression() #SelectExpression: {} {
    LOOKAHEAD(singleValuedPathExpression()) singleValuedPathExpression()
        | LOOKAHEAD(scalarExpression()) scalarExpression()
        | LOOKAHEAD(aggregateExpression()) aggregateExpression()
        | LOOKAHEAD(identificationVariable()) identificationVariable()
}

void derivedPathExpression(): {} {
    generalDerivedPath() <DOT> (
        LOOKAHEAD(singleValuedObjectField()) singleValuedObjectField()
        | LOOKAHEAD(collectionValuedField()) collectionValuedField()
    )
}

void generalDerivedPath(): {} {
    simpleDerivedPath()
    | treatedDerivedPath() optionalSingleValuedObjectFieldPath()
}

void simpleDerivedPath(): {} {
    superqueryIdentificationVariable() optionalSingleValuedObjectFieldPath()
}

void treatedDerivedPath(): {} {
    <TREAT> <LEFT_PAREN> generalDerivedPath() <AS> subType() <RIGHT_PAREN>
}

void derivedCollectionMemberDeclaration(): {} {
    <IN> superqueryIdentificationVariable() <DOT> ( singleValuedObjectField() <DOT> )* collectionValuedField()
}

void scalarExpression(): {} {
    LOOKAHEAD(arithmeticExpression()) arithmeticExpression()
    | LOOKAHEAD(stringExpression()) stringExpression()
    | LOOKAHEAD(enumExpression()) enumExpression()
    | LOOKAHEAD(dateTimeExpression()) dateTimeExpression()
    | LOOKAHEAD(booleanExpression()) booleanExpression()
    | LOOKAHEAD(caseExpression()) caseExpression()
    | LOOKAHEAD(entityTypeExpression()) entityTypeExpression()
}

void functionsReturningStrings(): {} {
    concat() | substring() | trim() | lower() | upper()
}

void functionsReturningNumerics(): {} {
    abs() | sqrt() | mod() | size() | index() | length() | locate()
}

void functionsReturningDatetime(): {} {
    (<CURRENT_DATE> #CurrentDate)
    | (<CURRENT_TIME> #CurrentTime)
    | (<CURRENT_TIMESTAMP> #CurrentTimestamp)
}

void functionInvocation(): {} {
    <FUNCTION> <LEFT_PAREN> functionName() ( <COMMA> functionArg() )* <RIGHT_PAREN>
}

void functionName(): {} {
    dotIdentifierSequence()
}

void functionArg(): {} {
    literal()
    | stateValuedPathExpression()
    | inputParameter()
    | scalarExpression()
}

void caseExpression(): {} {
    caseWhenExpression() | coalesceExpression() | nullifExpression()
}

void caseWhenExpression() #Case: {} {
    <CASE> ((whenClause())+ | caseOperand() (simpleWhenClause())+) <ELSE> scalarExpression() <END>
}

void whenClause() #When: {} {
    <WHEN> conditionalExpression() <THEN> scalarExpression()
}

void caseOperand(): {} {
    stateValuedPathExpression() | typeDiscriminator()
}

void simpleWhenClause() #When: {} {
    <WHEN> scalarExpression() <THEN> scalarExpression()
}

void coalesceExpression() #Coalesce: {} {
    <COALESCE> <LEFT_PAREN> scalarExpression() (<COMMA> scalarExpression())+ <RIGHT_PAREN>
}

void nullifExpression() #Nullif: {} {
    <NULLIF> <LEFT_PAREN> scalarExpression() <COMMA> scalarExpression() <RIGHT_PAREN>
}

void entityTypeExpression(): {} {
    typeDiscriminator() | entityTypeLiteral() | inputParameter()
}

void typeDiscriminator() #Type: {} {
    <TYPE> <LEFT_PAREN> (
        LOOKAHEAD(mapFieldIdentificationVariable()) mapFieldIdentificationVariable()
        | LOOKAHEAD(singleValuedObjectPathExpression()) singleValuedObjectPathExpression()
        | LOOKAHEAD(inputParameter()) inputParameter()
    ) <RIGHT_PAREN>
}

void entityTypeLiteral(): {} {
    entityName()
}

void size() #Size: {} {
    <SIZE> <LEFT_PAREN> singleValuedPathExpression() <RIGHT_PAREN>
}

void index() #Index: {} {
    <INDEX> <LEFT_PAREN> singleValuedPathExpression() <RIGHT_PAREN>
}

void length() #Length: {} {
    <LENGTH> <LEFT_PAREN> stringExpression() <RIGHT_PAREN>
}

void locate() #Locate: {} {
    <LOCATE> <LEFT_PAREN> stringExpression() <COMMA> stringExpression()
        [<COMMA> arithmeticExpression()] <RIGHT_PAREN>
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// GROUP BY clause

void groupByClause() #GroupBy: {} {
    <GROUP> <BY> groupByItem() ( LOOKAHEAD(2) <COMMA> groupByItem() )*
}

void groupByItem(): {} {
    LOOKAHEAD(singleValuedPathExpression()) singleValuedPathExpression()
    | LOOKAHEAD(inputParameter()) inputParameter()
    | LOOKAHEAD(identificationVariable()) identificationVariable()
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//HAVING clause

void havingClause() #Having: {} {
    <HAVING> conditionalExpression()
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// SELECT clause

void selectClause() #SelectClause: {} {
    <SELECT> [hint()] [distinct()] selectItems()
}

void hint() #Hint: {} {
    "/*" hintValues() "*/"
}

void hintValues(): {} {
    (<IS_ACCESSIBLE_NODB>#NoDbIsAccessible|<QUERY_OPTIMIZE_NOCACHE>#NoCacheQueryOptimize|<IS_ACCESSIBLE_NOCACHE>#NoCacheIsAccessible)+
}

void selectItems() #SelectExpressions: {} {
    selectExpression() ( <COMMA> selectExpression() )*
}

void selectItem(): {} {
    selectExpression() ([<AS>] resultVariable())?
}

void selectExpression() #SelectExpression: {} {
    LOOKAHEAD(singleValuedPathExpression()) singleValuedPathExpression()
    | LOOKAHEAD(scalarExpression()) scalarExpression()
    | LOOKAHEAD(aggregateExpression()) aggregateExpression()
    | LOOKAHEAD(identificationVariable()) identificationVariable()
    | LOOKAHEAD(objectFunction()) objectFunction()
    | LOOKAHEAD(constructorExpression()) constructorExpression()
}

void resultVariable(): {} {
    identifier()
}

void superqueryIdentificationVariable(): {} {
    identificationVariable()
}

void singleValuedObjectField(): {} {
    classOrFieldName()
}

void collectionValuedField(): {} {
    classOrFieldName()
}

void singleValuedEmbeddableObjectField(): {} {
    classOrFieldName()
}

void stateField(): {} {
    identifier()
}

void constructorExpression() #Constructor: {} {
    <NEW> constructorName() <LEFT_PAREN> constructorItem() ( <COMMA> (constructorItem()) )* <RIGHT_PAREN>
}

void constructorName() #ClassName: {} {
    classOrFieldName()
}

void classOrFieldName(): {} {
    identificationVariable() ( <DOT> identifier() )*
}

void constructorItem() #ConstructorParameter: {} {
    LOOKAHEAD(singleValuedPathExpression()) singleValuedPathExpression()
    | LOOKAHEAD(scalarExpression()) scalarExpression()
    | LOOKAHEAD(aggregateExpression()) aggregateExpression()
    | inputParameter()
}

void objectFunction() #ObjectFunction: {} {
    (<OBJECT> <LEFT_PAREN> identificationVariable() <RIGHT_PAREN>) [[<AS>] identificationVariable()]
}

void aggregateExpression(): {} {
    LOOKAHEAD(1) ( <AVG> | <MAX> | <MIN> | <SUM> ) <LEFT_PAREN> [<DISTINCT> #Distinct] stateValuedPathExpression() <RIGHT_PAREN>
                                                                                    #AggregateGeneralFunction
    | LOOKAHEAD(1) <COUNT> <LEFT_PAREN> [<DISTINCT> #Distinct] (
        LOOKAHEAD(identificationVariable()) identificationVariable()
        | LOOKAHEAD(stateValuedPathExpression()) stateValuedPathExpression()
        | LOOKAHEAD(singleValuedObjectPathExpression()) singleValuedObjectPathExpression()
    ) <RIGHT_PAREN>                                                                 #AggregateCountFunction
    //| functionInvocation()                                                          #AggregateFunctionInvocation
}

void concat() #Concat: {} {
    <CONCAT> <LEFT_PAREN> stringExpression() (<COMMA> stringExpression())+<RIGHT_PAREN>
}

void substring() #Substring: {} {
    <SUBSTRING> <LEFT_PAREN> stringExpression() <COMMA> arithmeticExpression() <COMMA> arithmeticExpression() <RIGHT_PAREN>
}

void trim() #Trim: {} {
    <TRIM> <LEFT_PAREN> [[trimSpecification()] [trimCharacter()] <FROM>] stringExpression() <RIGHT_PAREN>
}

void trimSpecification(): {} {
    LOOKAHEAD(2) (<LEADING> #TrimLeading) | (<TRAILING> #TrimTrailing) | (<BOTH> #TrimBoth)
}

void trimCharacter() #TrimCharacter: {} {
    characterLiteral() | stringLiteral()
}

void upper() #Upper: {} {
    <UPPER> <LEFT_PAREN> stringExpression() <RIGHT_PAREN>
}

void lower() #Lower: {} {
    <LOWER> <LEFT_PAREN> stringExpression() <RIGHT_PAREN>
}

void abs() #Abs: {} {
    <ABS> <LEFT_PAREN> arithmeticExpression() <RIGHT_PAREN>
}

void sqrt() #Sqrt: {} {
    <SQRT> <LEFT_PAREN> arithmeticExpression() <RIGHT_PAREN>
}

void mod() #Mod: {} {
    <MOD> <LEFT_PAREN> arithmeticExpression() <COMMA> arithmeticExpression() <RIGHT_PAREN>
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// EXPRESSIONS

void arithmeticExpression(): {} {
    arithmeticTerm()
    | LOOKAHEAD(2) (( <PLUS> arithmeticExpression() #Add(2) ) | ( <MINUS> arithmeticTerm() #Subtract(2) ))
}

void arithmeticTerm(): {} {
    arithmeticFactor()
    | LOOKAHEAD(2) (( <TIMES> arithmeticTerm() #Multiply(2) ) | ( <DIV> arithmeticFactor() #Divide(2) ))
}

void arithmeticFactor(): {} {
    ( ( <PLUS> | <MINUS> )? #UnaryOperator ) arithmeticPrimary()
}

void arithmeticPrimary(): {} {
    stateValuedPathExpression()
    | LOOKAHEAD(numericLiteral()) numericLiteral()
    | LOOKAHEAD(inputParameter()) inputParameter()
    | LOOKAHEAD(functionsReturningNumerics()) functionsReturningNumerics()
    | LOOKAHEAD(aggregateExpression()) aggregateExpression()
    | LOOKAHEAD(caseExpression()) caseExpression()
    // | LOOKAHEAD(functionInvocation()) functionInvocation()
    | LOOKAHEAD(<LEFT_PAREN> arithmeticExpression()) <LEFT_PAREN> arithmeticExpression() <RIGHT_PAREN> #Brackets(1)
    | LOOKAHEAD(subQueryInBrackets()) subQueryInBrackets()
}

void stringExpression(): {} {
    stateValuedPathExpression()
    | stringLiteral()
    | LOOKAHEAD(inputParameter()) inputParameter()
    | LOOKAHEAD(functionsReturningStrings()) functionsReturningStrings()
    | LOOKAHEAD(aggregateExpression()) aggregateExpression()
    | LOOKAHEAD(caseExpression()) caseExpression()
    // | LOOKAHEAD(functionInvocation()) functionInvocation()
    | <CURRENT_PRINCIPAL>
    | LOOKAHEAD(subQueryInBrackets()) subQueryInBrackets()
}

void dateTimeExpression(): {} {
    stateValuedPathExpression()
    | dateTimeTimestampLiteral()
    | LOOKAHEAD(inputParameter()) inputParameter()
    | LOOKAHEAD(functionsReturningDatetime()) functionsReturningDatetime()
    | LOOKAHEAD(aggregateExpression()) aggregateExpression()
    | LOOKAHEAD(caseExpression()) caseExpression()
    // | LOOKAHEAD(functionInvocation()) functionInvocation()
    | LOOKAHEAD(subQueryInBrackets()) subQueryInBrackets()
}

void booleanExpression(): {} {
    stateValuedPathExpression()
    | booleanLiteral()
    | LOOKAHEAD(inputParameter()) inputParameter()
    | LOOKAHEAD(caseExpression()) caseExpression()
    // | LOOKAHEAD(functionInvocation()) functionInvocation()
    | LOOKAHEAD(subQueryInBrackets()) subQueryInBrackets()
}

void enumExpression(): {} {
    LOOKAHEAD(stateValuedPathExpression()) stateValuedPathExpression()
    | LOOKAHEAD(enumLiteral()) enumLiteral()
    | LOOKAHEAD(inputParameter()) inputParameter()
    | LOOKAHEAD(caseExpression()) caseExpression()
}

void dateTimeTimestampLiteral(): {} {
    <DATE_LITERAL>
    | <TIME_LITERAL>
    | <TIMESTAMP_LITERAL>
}

void enumLiteral(): {} {
    singleValuedPathExpression()
}


void entityExpression(): {} {
    singleValuedObjectPathExpression()
    | simpleEntityExpression()
    | <CURRENT_PRINCIPAL>
    | <CURRENT_TENANT>
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// WHERE clause

JpqlWhere whereClause() #Where: {} {
    <WHERE> conditionalExpression() { return jjtThis; }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ORDER BY clause

void orderByClause() #OrderBy: {} {
    <ORDER> <BY> orderByItem() (<COMMA> orderByItem())*
}

void orderByItem() #OrderByItem: {} {
    singleValuedPathExpression() [ <ASC> #Ascending | <DESC> #Descending ]
}

void identifier(): {} {
    <IDENTIFIER>
    //token = <IDENTIFIER> { jjtThis.setValue(token.image); }
    //| reservedKeywords()
}

void reservedKeywords() #ReservedKeywords: { Token token; } {
    (
        token = <NEW>
        | token = <ALL>
        | token = <ANY>
        | token = <EXISTS>
        | token = <SOME>
        | token = <EMPTY>
        | token = <ASC>
        | token = <DESC>
        | token = <ORDER>
        | token = <IS>
        | token = <MEMBER>
        | token = <OF>
        | token = <LIKE>
        | token = <ESCAPE>
        | token = <BETWEEN>
        | token = <NULL>
        | token = <AVG>
        | token = <MIN>
        | token = <MAX>
        | token = <SUM>
        | token = <COUNT>
        | token = <OR>
        | token = <AND>
        | token = <NOT>
        | token = <CONCAT>
        | token = <SUBSTRING>
        | token = <TRIM>
        | token = <LOWER>
        | token = <UPPER>
        | token = <LEADING>
        | token = <TRAILING>
        | token = <BOTH>
        | token = <LENGTH>
        | token = <LOCATE>
        | token = <ABS>
        | token = <SQRT>
        | token = <MOD>
        | token = <SIZE>
        | token = <CURRENT_DATE>
        | token = <CURRENT_TIME>
        | token = <CURRENT_TIMESTAMP>
        | token = <CASE>
        | token = <WHEN>
        | token = <THEN>
        | token = <ELSE>
        | token = <END>
        | token = <SELECT>
        | token = <DISTINCT>
        | token = <FROM>
        | token = <UPDATE>
        | token = <DELETE>
        | token = <WHERE>
        | token = <GROUP>
        | token = <BY>
        | token = <HAVING>
        | token = <AS>
        | token = <LEFT>
        | token = <OUTER>
        | token = <INNER>
        | token = <JOIN>
        | token = <FETCH>
        | token = <IN>
        | token = <SET>
        | token = <OBJECT>
        | token = <GRANT>
        | token = <CREATE>
        | token = <READ>
        | token = <ACCESS>
        | token = <TYPE>
        | token = <VALUE>
        | token = <KEY>
        | token = <ENTRY>
    ) { jjtThis.setValue(token.image); }
}

void mapFieldIdentificationVariable(): {} {
    key() | value()
}

void qualifiedIdentificationVariable(): {} {
   mapFieldIdentificationVariable() | entry()
}

void generalIdentificationVariable(): {} {
    identificationVariable()
    | mapFieldIdentificationVariable()
}

void generalSubPath(): {} {
    simpleSubPath()
    | treatedSubPath() optionalSingleValuedObjectFieldPath()
}

void simpleSubPath(): {} {
    generalIdentificationVariable() optionalSingleValuedObjectFieldPath()
}

void optionalSingleValuedObjectFieldPath(): {} {
    ( <DOT> singleValuedObjectField() )*
}

void treatedSubPath(): {} {
    LOOKAHEAD(6) <TREAT> <LEFT_PAREN> generalSubPath() <AS> subType() <RIGHT_PAREN>
}

void singleValuedPathExpression() #Path: {} {
    LOOKAHEAD(qualifiedIdentificationVariable()) qualifiedIdentificationVariable()
    | LOOKAHEAD(6) <TREAT> <LEFT_PAREN> qualifiedIdentificationVariable() <AS> subType() <RIGHT_PAREN>
    | LOOKAHEAD(stateFieldPathExpression()) stateFieldPathExpression()
    | singleValuedObjectPathExpression()
}

void stateFieldPathExpression(): {} {
    generalSubPath() <DOT> stateField()
}

void stateValuedPathExpression(): {} {
    LOOKAHEAD(stateFieldPathExpression()) stateFieldPathExpression()
    | LOOKAHEAD(generalIdentificationVariable()) generalIdentificationVariable()
}

void singleValuedObjectPathExpression(): {} {
    generalSubPath() <DOT> singleValuedObjectField()
}

void collectionValuedPathExpression() #CollectionValuedPath: {} {
    generalSubPath() <DOT> collectionValuedField()
}

void dotIdentifierSequence(): {} {
    identifier() ( <DOT> dotIdentifierSequence() )?
}

void identificationVariable() #IdentificationVariable: { Token token; } {
    identifier()
}

void key() #Key: {} {
    <KEY> <LEFT_PAREN> identificationVariable() <RIGHT_PAREN>
}

void value() #Value: {} {
    <VALUE> <LEFT_PAREN> identificationVariable() <RIGHT_PAREN>
}

void entry() #Entry: {} {
    <ENTRY> <LEFT_PAREN> identificationVariable() <RIGHT_PAREN>
}

void objectField() #IdentificationVariable: { Token token; } {
    // unlike the identificationVariable(), the objectField() *can* be a reserved word.
    // E.g., Order.group.length is a perfectly valid path expression.
    (
    token = <IDENTIFIER>
    | token = <NEW>
    | token = <ALL>
    | token = <ANY>
    | token = <EXISTS>
    | token = <SOME>
    | token = <EMPTY>
    | token = <ASC>
    | token = <DESC>
    | token = <ORDER>
    | token = <IS>
    | token = <MEMBER>
    | token = <OF>
    | token = <LIKE>
    | token = <ESCAPE>
    | token = <BETWEEN>
    | token = <NULL>
    | token = <AVG>
    | token = <MIN>
    | token = <MAX>
    | token = <SUM>
    | token = <COUNT>
    | token = <OR>
    | token = <AND>
    | token = <NOT>
    | token = <CONCAT>
    | token = <SUBSTRING>
    | token = <TRIM>
    | token = <LOWER>
    | token = <UPPER>
    | token = <LEADING>
    | token = <TRAILING>
    | token = <BOTH>
    | token = <LENGTH>
    | token = <LOCATE>
    | token = <ABS>
    | token = <SQRT>
    | token = <MOD>
    | token = <SIZE>
    | token = <CURRENT_DATE>
    | token = <CURRENT_TIME>
    | token = <CURRENT_TIMESTAMP>
    | token = <CASE>
    | token = <WHEN>
    | token = <THEN>
    | token = <ELSE>
    | token = <END>
    | token = <SELECT>
    | token = <DISTINCT>
    | token = <FROM>
    | token = <UPDATE>
    | token = <DELETE>
    | token = <WHERE>
    | token = <GROUP>
    | token = <BY>
    | token = <HAVING>
    | token = <AS>
    | token = <LEFT>
    | token = <OUTER>
    | token = <INNER>
    | token = <JOIN>
    | token = <FETCH>
    | token = <IN>
    | token = <SET>
    | token = <OBJECT>
    | token = <GRANT>
    | token = <CREATE>
    | token = <READ>
    | token = <ACCESS>
    | token = <TYPE>
    | token = <VALUE>
    | token = <KEY>
    | token = <ENTRY>
    ) { jjtThis.setValue(token.image); }
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// LITERALS

void literal() #Literal: {} {
    stringLiteral()
    | characterLiteral()
    | booleanLiteral()
    | numericLiteral()
    | timestampLiteral()
    | dateLiteral()
    | timeLiteral()
    | entityTypeLiteral()
    | <NULL>
}

void stringLiteral() #StringLiteral: { Token token; } {
    token = <STRING_LITERAL> { jjtThis.setValue(token.image); }
}

void characterLiteral() #CharacterLiteral: { Token token; } {
    token = <CHARACTER_LITERAL> { jjtThis.setValue(token.image); }
}

void numericLiteral() #NumericLiteral: { Token token; boolean negative = false; } {
    ( <MINUS> { negative = this.jj_kind == MINUS; } | <PLUS> )?
    (
        token = <INTEGER_LITERAL>                                       #IntegerLiteral
        | token = <LONG_LITERAL>                                        #LongLiteral
        | token = <BIG_INTEGER_LITERAL>                                 #BigIntegerLiteral
        | token = <FLOAT_LITERAL>                                       #FloatLiteral
        | token = <DOUBLE_LITERAL>                                      #DoubleLiteral
        | token = <BIG_DECIMAL_LITERAL>                                 #BigDecimalLiteral
        | token = <HEX_LITERAL>                                         #HexLiteral
        | token = <OCTAL_LITERAL>                                       #OctalLiteral
    ) { jjtThis.setValue(negative ? "-" : "" + token.image); }
}

void booleanLiteral() #BooleanLiteral: { Token token; } {
    token = <BOOLEAN_LITERAL> { jjtThis.setValue(token.image); }
}

void timestampLiteral() #TimestampLiteral: {} {
    <TIMESTAMP_LITERAL>
}

void dateLiteral() #DateLiteral: {} {
    <DATE_LITERAL>
}

void timeLiteral() #TimeLiteral: {} {
    <TIME_LITERAL>
}

void entityName() #AbstractSchemaName: {} {
    dotIdentifierSequence()
}

void inputParameter(): {} {
    namedInputParameter() | positionalInputParameter()
}

void namedInputParameter() #NamedInputParameter: { Token token; } {
    <COLON> identifier()
}

void positionalInputParameter() #PositionalInputParameter: { Token token; } {
    <QUESTION_MARK> token = <INTEGER_LITERAL> { jjtThis.setValue("?" + token.image); }
}

void singleValuedInputParameter() #singleValuedInputParameter: {} {
    namedInputParameter() | positionalInputParameter()
}

void collectionValuedInputParameter() #CollectionValuedInputParameter: {} {
    namedInputParameter() | positionalInputParameter()
}
